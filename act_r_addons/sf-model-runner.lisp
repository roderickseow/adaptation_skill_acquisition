;;; This file contains functions which will run models in the Space Fortress game
;;; either on the cluster or on a non-cluster machine in the same way.  Thus, if
;;; it works locally it will work the same on the cluster and vice-versa as long
;;; as these functions are used as-is -- don't modify this code or copy them and 
;;; use other modified versions.
;;; 
;;;
;;; It provides two functions:
;;;
;;; run-local-model (model command parameters &key model-files results-file timeout debugging-files limit)
;;; run-cluster-model (model command parameters-lists &key model-files (results-file t) (timeout 30) debugging-files limit)
;;;
;;;
;;; Both work the same way.  They require the name of a model file, the name of
;;; the function to call to run the model in the task, and a list of parameters to
;;; pass to that function (for the cluster version it is a list of parameter lists
;;; with each parameter list being passed to separate instance of the model).
;;; Additional files to load (before the model) can be specified in a list using the
;;; :model-files keyword parameter. 
;;;
;;; All the files must be located in the same directory as this file.
;;;
;;; These additional keyword parameters can be useful for the cluster (they are 
;;; just ignored for a local run):
;;;
;;; :results-file is a boolean indicating whether or not to save a file with the
;;; return value from the run function for each model.
;;;
;;; :timeout is a number in minutes indicating how long a model will be allowed
;;; to run before killing it.
;;;
;;; :debugging-files a boolean indicating whether or not to save the output files
;;; generated by each model along with the file of parameters which was passed to it.
;;;
;;; :limit a number specifying how many models should be run at a time.  The default is 
;;; 95 which means a total of 6 nodes assuming a single cpu was taken for the initial run.
;;; Larger values should only be used if one knows for certain that there will be
;;; sufficient resources available and it will not block access to other users.
;;; 
;;;
;;; When these functions are called the following sequence of actions occurs.  For
;;; the local version it happens in the current Lisp and for the cluster version it
;;; starts a fresh Lisp for each model:
;;;
;;; - Load ACT-R if needed
;;; - Start the game server running if it hasn't already been started
;;; - load the indicate additional files
;;; - load the model file or use ACT-R reload command if it was already loaded
;;; - pass the provided parameters to the run function
;;;
;;; For the local version it returns the result of calling that function, and for
;;; the cluster version it returns two values: a list of the results for each model
;;; that was run and the id for the data files.


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Eliminate warnings about functions not being defined yet.

(declaim (ftype (function (&optional t) t) sfapi-create-client))
(declaim (ftype (function (t) t) sfapi-check))
(declaim (ftype (function (t t) t) set-server-script-location-for-cluster))
(declaim (ftype (function (&optional t) t) reload))
(declaim (ftype (function (t &optional t) t) compile-and-load))
(declaim (ftype (function (t &optional t) t) written-for-act-r-version))
(declaim (ftype (function (t t t &key &allow-other-keys) t) cluster-apply))
(declaim (ftype (function (t) t) ssp-fct))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Logical for the top level of the files


(setf (logical-pathname-translations "SF-TOP-LEVEL")
  `(("**;*.*" ,(namestring (merge-pathnames "**/*.*" *load-truename*)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; The actual functions


(defun run-cluster-model (model run-function parameters-lists &key model-files (results-file t) (debugging-files nil) (timeout 30) limit)
  (require "CLUSTER-RUN" (translate-logical-pathname "SF-TOP-LEVEL:cluster-run.lisp"))
  
  ;; assume that ACL only runs on old cluster.
  ;; For CCL check if we have a slurm node to decide which mode.
  ;; Note: That means it will fail if attempted from the head node
  ;;       on the new cluster which is a good thing!
  
  (if (find :allegro *features*) 
      (setf *cluster-run-mode* :pbs)
    #+:ccl (if (ccl:getenv "SLURMD_NODENAME")
               (setf *cluster-run-mode* :slurm)
             (setf *cluster-run-mode* :pbs))
    #-:ccl (error "Only works with ACL and CCL."))
  
  (let ((*print-pretty* nil))
    
    (multiple-value-bind (results success number id)
        (cluster-apply (append (list "load-act-r-sf.lisp") model-files (list (translate-logical-pathname "SF-TOP-LEVEL:external-server.lisp")) (list model))
                       run-function 
                       parameters-lists 
                       :processors 1
                       :limit (if (numberp limit) limit 95) 
                       :timeout (list 0 timeout 0) 
                       :errors-in-results t 
                       :output-files debugging-files 
                       :save-params-files debugging-files)
      (declare (ignore number))
      
      (unless success
        (format t "One or more models did not complete successfully.~%"))
      
      (when results-file
        (with-open-file (f (format nil "model-results-~d.txt" id) :direction :output :if-exists :supersede :if-does-not-exist :create)
          (dotimes (i (length parameters-lists))
            (if (keywordp (nth i results))
                (format f "model_~d_~d,~s,ERROR~%" id (1+ i) (nth i parameters-lists))
              (format f "model_~d_~d,~s,~s~%" id (1+ i) (nth i parameters-lists) (nth i results))))))
      (values results id))))


(defvar *last-model* nil)


;; Hack to get around allegro not liking a . in a logical pathname...
(defun allegro-translate-hack (dirs name type)
  (make-pathname :name name
                 :type type
                 :directory (append (pathname-directory (translate-logical-pathname "SF-TOP-LEVEL:")) (if (listp dirs)
                                                                                                          dirs
                                                                                                        (list dirs)))))
(defun run-local-model (model run-function parameters &key model-files results-file debugging-files timeout limit)
  (declare (ignore results-file debugging-files timeout limit))
  (unless (find :act-r *features*) 
    (let ((path #-:allegro (translate-logical-pathname "SF-TOP-LEVEL:actr7.x;load-act-r.lisp")
                #+:allegro (allegro-translate-hack "actr7.x" "load-act-r" "lisp")))
    (load path)))
  
  (written-for-act-r-version "7.14" "this to work")
  
  (dolist (x model-files)
    (compile-and-load (translate-logical-pathname (concatenate 'string "SF-TOP-LEVEL:" x))))
  
  (if (string-equal model *last-model*)
      (reload)
    (progn
      (load (translate-logical-pathname (concatenate 'string "SF-TOP-LEVEL:" model)))
      (setf *last-model* model)))
  
  #+:linux 
  (progn
    (set-server-script-location-for-cluster (namestring (translate-logical-pathname "SF-TOP-LEVEL:headless-server-linux")) "" )
    
    (ssp-fct (list :starting-parameters '(:sf-server-type sfapi-external-process-client)))
    
    (unless (sfapi-check (sfapi-create-client :external-process))
      (format t "~%Game server application isn't available~%")
      (return-from run-local-model nil)))

  
  #+(or :windows :mswindows) 
  (unless (sfapi-check (sfapi-create-client :tcp))
    (sfapi-run-program (namestring (translate-logical-pathname "SF-TOP-LEVEL:SpaceFortressServer-win32-x64;SpaceFortressServer.exe")) nil)
    (let ((tries 0))
      (loop 
        (when (> tries 10)
          (format t "%Can't connect to game server~%")
          (return-from run-local-model nil))
        (when (sfapi-check (sfapi-create-client :tcp))
          (return))
        (incf tries)
        (sleep 2))))
  
  #+:darwin 
  (unless (sfapi-check (sfapi-create-client :tcp))
    (sfapi-run-program (namestring (translate-logical-pathname "SF-TOP-LEVEL:SpaceFortressServer.app;Contents;MacOS;SpaceFortressServer")) nil)
    (let ((tries 0))
      (loop 
        (when (> tries 10)
          (format t "%Can't connect to game server~%")
          (return-from run-local-model nil))
        (when (sfapi-check (sfapi-create-client :tcp))
          (return))
        (incf tries)
        (sleep 2))))
  
  (apply run-function parameters))
